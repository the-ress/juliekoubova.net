'use strict';

exports.__esModule = true;

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _defined = require('defined');

var _defined2 = _interopRequireDefault(_defined);

var _deeplyNested = require('./deeplyNested');

var _deeplyNested2 = _interopRequireDefault(_deeplyNested);

var _getIndent = require('./getIndent');

var _getIndent2 = _interopRequireDefault(_getIndent);

var _longest = require('./longest');

var _longest2 = _interopRequireDefault(_longest);

var _maxSelectorLength = require('./maxSelectorLength');

var _prefixedDecls = require('./prefixedDecls');

var _prefixedDecls2 = _interopRequireDefault(_prefixedDecls);

var _space = require('./space');

var _space2 = _interopRequireDefault(_space);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _commentRegex = require('comment-regex');

var _sameLine = require('./sameLine');

var _sameLine2 = _interopRequireDefault(_sameLine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var unprefix = _postcss2.default.vendor.unprefixed;

function isSassVariable(decl) {
    return decl.parent.type === 'root' && decl.prop.match(/^\$/);
}

function blank(value) {
    return (0, _defined2.default)(value, '');
}

function applyCompressed(css) {
    css.walk(function (rule) {
        rule.raws.semicolon = false;
        if (rule.type === 'comment' && rule.raws.inline) {
            rule.raws.inline = null;
        }
        if (rule.type === 'rule' || rule.type === 'atrule') {
            rule.raws.between = rule.raws.after = '';
        }
        if (rule.type === 'decl' && !(0, _commentRegex.block)().test(rule.raws.between)) {
            rule.raws.between = ':';
        }
        if (rule.type === 'decl') {
            if (rule.raws.value) {
                rule.value = rule.raws.value.raw.trim();
            }
            // Format sass variable `$size: 30em;`
            if (isSassVariable(rule)) {
                rule.raws.before = '';
                rule.raws.between = ':';
                rule.value = rule.value.trim().replace(/\s+/g, ' ');
            }

            // Remove spaces before commas and keep only one space after.
            rule.value = rule.value.replace(/(\s+)?,(\s)*/g, ',');
            rule.value = rule.value.replace(/\(\s*/g, '(');
            rule.value = rule.value.replace(/\s*\)/g, ')');

            // Format `!important`
            if (rule.important) {
                rule.raws.important = '!important';
            }

            // Format `!default`, `!global` and more similar values.
            if (rule.value.match(/\s*!\s*(\w+)\s*$/i) !== null) {
                rule.value = rule.value.replace(/\s*!\s*(\w+)\s*$/i, '!$1');
            }

            if (rule.raws.value) {
                rule.raws.value.raw = rule.value;
            }
        }
    });
    // Remove final newline
    css.raws.after = '';
}

function applyCompact(css, opts) {
    css.walk(function (rule) {
        if (rule.type === 'decl') {
            if (rule.raws.value) {
                rule.value = rule.raws.value.raw.trim();
            }
            // Format sass variable `$size: 30em;`
            if (isSassVariable(rule)) {
                rule.raws.before = '';
                rule.raws.between = ': ';
                rule.value = rule.value.trim().replace(/\s+/g, ' ');
            }

            // Remove spaces before commas and keep only one space after.
            rule.value = rule.value.replace(/(\s*,\s*)(?=(?:[^"']|['"][^"']*["'])*$)/g, ', ');
            rule.value = rule.value.replace(/\(\s*/g, '( ');
            rule.value = rule.value.replace(/\s*\)/g, ' )');
            // Remove space after comma in data-uri
            rule.value = rule.value.replace(/(data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+\=[a-z0-9\-]+)?)?(;base64)?,)\s+/g, '$1');

            // Format `!important`
            if (rule.important) {
                rule.raws.important = " !important";
            }

            // Format `!default`, `!global` and more similar values.
            if (rule.value.match(/\s*!\s*(\w+)\s*$/i) !== null) {
                rule.value = rule.value.replace(/\s*!\s*(\w+)\s*$/i, ' !$1');
            }

            if (rule.raws.value) {
                rule.raws.value.raw = rule.value;
            }
        }
        opts.indentSize = 1;
        if (rule.type === 'comment') {
            if (rule.raws.inline) {
                rule.raws.inline = null;
            }
            var prev = rule.prev();
            if (prev && prev.type === 'decl') {
                rule.raws.before = ' ' + blank(rule.raws.before);
            }
            if (rule.parent && rule.parent.type === 'root') {
                var next = rule.next();
                if (next) {
                    next.raws.before = '\n';
                }
                if (rule !== css.first) {
                    rule.raws.before = '\n';
                }
            }
            return;
        }
        var indent = (0, _getIndent2.default)(rule, opts.indentSize);
        var deep = (0, _deeplyNested2.default)(rule);
        if (rule.type === 'rule' || rule.type === 'atrule') {
            if (!rule.nodes) {
                rule.raws.between = '';
            } else {
                rule.raws.between = ' ';
            }
            rule.raws.after = ' ';
            rule.raws.before = indent + blank(rule.raws.before);
            rule.raws.semicolon = true;
        }
        if (rule.raws.selector && rule.raws.selector.raw) {
            rule.selector = rule.raws.selector.raw;
        }
        (0, _maxSelectorLength.maxSelectorLength)(rule, opts);
        if (rule.type === 'decl') {
            if ((0, _deeplyNested2.default)(rule.parent)) {
                var newline = rule === css.first ? '' : '\n';
                rule.raws.before = newline + indent + blank(rule.raws.before);
            } else {
                rule.raws.before = ' ' + blank(rule.raws.before);
            }
            if (!(0, _commentRegex.block)().test(rule.raws.between)) {
                rule.raws.between = ': ';
            }
        }
        if ((deep || rule.nodes) && rule !== css.first) {
            rule.raws.before = '\n ';
        }
        if (deep) {
            rule.raws.after = '\n' + indent;
        }
        if (rule.parent && rule !== rule.parent.first && (rule.type === 'rule' || rule.type === 'atrule')) {
            rule.raws.before = '\n' + indent;
        }
    });
    css.raws.after = '\n';
}

function applyExpanded(css, opts) {
    css.walk(function (rule) {
        if (rule.type === 'decl') {
            if (rule.raws.value) {
                rule.value = rule.raws.value.raw.trim();
            }
            // Format sass variable `$size: 30em;`
            if (isSassVariable(rule)) {
                if (rule !== css.first) {
                    rule.raws.before = '\n';
                }
                rule.raws.between = ': ';
            }

            rule.value = rule.value.trim().replace(/\s+/g, ' ');
            // Remove spaces before commas and keep only one space after.
            rule.value = rule.value.replace(/(\s*,\s*)(?=(?:[^"']|['"][^"']*["'])*$)/g, ', ');
            rule.value = rule.value.replace(/\(\s*/g, '(');
            rule.value = rule.value.replace(/\s*\)/g, ')');
            // Remove space after comma in data-uri
            rule.value = rule.value.replace(/(data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+\=[a-z0-9\-]+)?)?(;base64)?,)\s+/g, '$1');

            // Format `!important`
            if (rule.important) {
                rule.raws.important = " !important";
            }

            // Format `!default`, `!global` and more similar values.
            if (rule.value.match(/\s*!\s*(\w+)\s*$/i) !== null) {
                rule.value = rule.value.replace(/\s*!\s*(\w+)\s*$/i, ' !$1');
            }

            if (rule.raws.value) {
                rule.raws.value.raw = rule.value;
            }
        }
        var indent = (0, _getIndent2.default)(rule, opts.indentSize);
        if (rule.type === 'comment') {
            var prev = rule.prev();
            if (prev && prev.type === 'decl') {
                if ((0, _sameLine2.default)(prev, rule)) {
                    rule.raws.before = ' ' + blank(rule.raws.before);
                } else {
                    rule.raws.before = '\n' + indent + blank(rule.raws.before);
                }
            }
            if (!prev && rule !== css.first) {
                rule.raws.before = '\n' + indent + blank(rule.raws.before);
            }
            if (rule.parent && rule.parent.type === 'root') {
                var next = rule.next();
                if (next) {
                    next.raws.before = '\n\n';
                }
                if (rule !== css.first) {
                    rule.raws.before = '\n\n';
                }
            }
            return;
        }
        rule.raws.before = indent + blank(rule.raws.before);
        if (rule.type === 'rule' || rule.type === 'atrule') {
            if (!rule.nodes) {
                rule.raws.between = '';
            } else {
                rule.raws.between = ' ';
            }
            rule.raws.semicolon = true;
            if (rule.nodes) {
                rule.raws.after = '\n';
            }
        }
        // visual cascade of vendor prefixed properties
        if (opts.cascade && rule.type === 'rule' && rule.nodes.length > 1) {
            (function () {
                var props = [];
                var prefixed = (0, _prefixedDecls2.default)(rule).sort(_longest2.default).filter(function (_ref) {
                    var prop = _ref.prop;

                    var base = unprefix(prop);
                    if (! ~props.indexOf(base)) {
                        return props.push(base);
                    }
                    return false;
                });
                prefixed.forEach(function (prefix) {
                    var base = unprefix(prefix.prop);
                    var vendor = prefix.prop.replace(base, '').length;
                    rule.nodes.filter(function (_ref2) {
                        var prop = _ref2.prop;
                        return prop && ~prop.indexOf(base);
                    }).forEach(function (decl) {
                        var thisVendor = decl.prop.replace(base, '').length;
                        var extraSpace = vendor - thisVendor;
                        if (extraSpace > 0) {
                            decl.raws.before = (0, _space2.default)(extraSpace) + blank(decl.raws.before);
                        }
                    });
                });
            })();
        }
        if (rule.raws.selector && rule.raws.selector.raw) {
            rule.selector = rule.raws.selector.raw;
        }
        (0, _maxSelectorLength.maxSelectorLength)(rule, opts);
        if (rule.type === 'atrule') {
            if (rule.params) {
                rule.raws.afterName = ' ';
            }
            (0, _maxSelectorLength.maxAtRuleLength)(rule, opts);
        }
        if (rule.type === 'decl') {
            if (!(0, _commentRegex.block)().test(rule.raws.between)) {
                rule.raws.between = ': ';
            }
            (0, _maxSelectorLength.maxValueLength)(rule, opts);
        }
        if (rule.parent && rule.parent.type !== 'root') {
            rule.raws.before = '\n' + blank(rule.raws.before);
            rule.raws.after = '\n' + indent;
        }
        if (rule.parent && rule !== rule.parent.first && (rule.type === 'rule' || rule.type === 'atrule')) {
            if (rule.type === 'atrule' && !rule.nodes) {
                rule.raws.before = '\n' + indent;
                return;
            }
            rule.raws.before = '\n\n' + indent;
        }
    });
    css.raws.after = '\n';
}

var perfectionist = _postcss2.default.plugin('perfectionist', function (opts) {
    opts = (0, _objectAssign2.default)({
        format: 'expanded',
        indentSize: 4,
        maxAtRuleLength: 80,
        maxSelectorLength: 80,
        maxValueLength: 80,
        cascade: true
    }, opts);
    return function (css) {
        css.walk(function (node) {
            if (node.raws.before) {
                node.raws.before = node.raws.before.replace(/[;\s]/g, '');
            }
        });
        switch (opts.format) {
            case 'compact':
                applyCompact(css, opts);
                break;
            case 'compressed':
                applyCompressed(css);
                break;
            case 'expanded':
                applyExpanded(css, opts);
                break;
        }
    };
});

perfectionist.process = function (css) {
    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    opts.map = opts.map || (opts.sourcemap ? true : null);
    if (opts.syntax === 'scss') {
        opts.syntax = require('postcss-scss');
    }
    var processor = (0, _postcss2.default)([perfectionist(opts)]);
    return processor.process(css, opts);
};

exports.default = perfectionist;
module.exports = exports['default'];